{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlashFIX","text":"<p>FlashFIX is a fast and efficient library for working with FIX protocol messages. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>todo</p>"},{"location":"api-reference/data-structures/","title":"Data Structures","text":""},{"location":"api-reference/data-structures/#messages","title":"Messages","text":"<p>Included in the <code>flashfix/structs.h</code> header file.</p> <pre><code>typedef struct\n{\n  uint16_t tag_len;\n  uint16_t value_len;\n  char *tag;\n  char *value;\n} ff_field_t;\n\ntypedef struct\n{\n  ff_field_t fields[FIX_MAX_FIELDS];\n  uint16_t n_fields;\n} ff_message_t;\n</code></pre>"},{"location":"api-reference/data-structures/#errors","title":"Errors","text":"<p>Included in the <code>flashfix/errors.h</code> header file.</p> <pre><code>typedef enum\n{\n  FF_OK = 0,\n  FF_INVALID_MESSAGE,\n  FF_BODY_LENGTH_MISMATCH,\n  FF_CHECKSUM_MISMATCH,\n  FF_TOO_MANY_FIELDS,\n  FF_MESSAGE_TOO_BIG\n} ff_error_t;\n</code></pre>"},{"location":"api-reference/deserialization/","title":"Deserialization","text":"<p>The following function prototypes can be found in the <code>deserialization.h</code> header file.</p> <pre><code>#include &lt;flashfix/deserialization.h&gt;\n</code></pre> <p>These functions only verify the structural integrity of messages in terms of format, checksum, and body length. They do not validate the correctness of the messages (e.g. duplicate tags, invalid values, etc.).</p>"},{"location":"api-reference/deserialization/#ff_is_full_message","title":"ff_is_full_message","text":"<pre><code>bool ff_is_full_message(const char *restrict buffer, const uint16_t buffer_size, const uint16_t message_len, ff_error_t *restrict error);\n</code></pre>"},{"location":"api-reference/deserialization/#description","title":"Description","text":"<p>checks if the buffer contains a full FIX message (aka full checksum is present).</p> <p>WARNING: if the buffer is too small (aka the partial message that arrived has filled the whole buffer) there is potential for an infinite loop if you keep repeating the call to <code>ff_is_full_message</code> with the same buffer and <code>buffer_size</code>, the function will yield a FF_MESSAGE_TOO_BIG error in that case, you should only call <code>ff_is_full_message</code> with a <code>NULL</code> error pointer if you have other ways to detect that the buffer is full</p>"},{"location":"api-reference/deserialization/#parameters","title":"Parameters","text":"<ul> <li><code>buffer</code> - the buffer which contains a full or partial serialized message</li> <li><code>buffer_size</code> - the size of the buffer in bytes</li> <li><code>message_len</code> - the length of the serialized message (portion of the buffer that is full)</li> <li><code>error</code> - an optional pointer to retrieve error information</li> </ul>"},{"location":"api-reference/deserialization/#returns","title":"Returns","text":"<ul> <li><code>true</code> if the buffer contains a full message</li> <li><code>false</code> if the buffer contains a partial message</li> <li><code>false</code> in case of error</li> </ul>"},{"location":"api-reference/deserialization/#undefined-behavior","title":"Undefined Behavior","text":"<ul> <li><code>buffer</code> is <code>NULL</code></li> <li><code>buffer_size</code> is different from the actual size of the buffer</li> <li><code>message_len</code> is different from the actual length of the message</li> <li><code>message_len</code> is bigger than <code>buffer_size</code></li> </ul>"},{"location":"api-reference/deserialization/#errors","title":"Errors","text":"<ul> <li><code>FF_MESSAGE_TOO_BIG</code> - the message is too big to fit in the buffer</li> </ul>"},{"location":"api-reference/deserialization/#ff_deserialize","title":"ff_deserialize","text":"<pre><code>uint16_t ff_deserialize(char *restrict buffer, const uint16_t buffer_size, ff_message_t *restrict message, ff_error_t *restrict error);\n</code></pre>"},{"location":"api-reference/deserialization/#description_1","title":"Description","text":"<p>deserializes a fix message by tokenizing the buffer in place: replacing <code>'='</code> and <code>'\\x01'</code> delimiters with <code>'\\0'</code> and store pointers to the beginning of each field in the message struct</p>"},{"location":"api-reference/deserialization/#parameters_1","title":"Parameters","text":"<ul> <li><code>buffer</code> - the buffer which contains the full serialized message</li> <li><code>buffer_size</code> - the size of the buffer in bytes</li> <li><code>message</code> - the message struct where to store the deserialized fields</li> <li><code>error</code> - an optional pointer to retrieve error information</li> </ul>"},{"location":"api-reference/deserialization/#returns_1","title":"Returns","text":"<ul> <li>length of the deserialized message in bytes</li> <li><code>0</code> in case of error</li> </ul>"},{"location":"api-reference/deserialization/#undefined-behavior_1","title":"Undefined Behavior","text":"<ul> <li><code>buffer</code> is <code>NULL</code></li> <li><code>message</code> is <code>NULL</code></li> <li><code>message-&gt;n_fields</code> is greater than <code>FIX_MAX_FIELDS</code></li> <li><code>buffer_size</code> is different from the actual size of the buffer</li> <li><code>buffer</code> does not contain a full message</li> <li><code>buffer</code> contains non printable characters</li> </ul>"},{"location":"api-reference/deserialization/#errors_1","title":"Errors","text":"<ul> <li><code>FF_INVALID_MESSAGE</code> - the message does not contain mandatory tags</li> <li><code>FF_BODY_LENGTH_MISMATCH</code> - the body length tag does not match the actual body length</li> <li><code>FF_CHECKSUM_MISMATCH</code> - the checksum tag does not match the actual checksum</li> </ul>"},{"location":"api-reference/overview/","title":"Overview","text":""},{"location":"api-reference/overview/#premise","title":"Premise","text":"<p>Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions, so this library requires careful use. </p> <p>Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, they do not validate the correctness of the messages. For more details, refer to the specific sections.</p>"},{"location":"api-reference/overview/#usage","title":"Usage","text":"<p>The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures for messages and errors.</p> <p>You can include both the serialization and deserialization headers in your project by including the main header file:</p> <pre><code>#include &lt;flashfix.h&gt;\n</code></pre> <p>otherwise, you can selectively include the headers you need:</p> <ul> <li>Serialization</li> <li>Deserialization</li> </ul>"},{"location":"api-reference/serialization/","title":"Serialization","text":"<p>The following function prototypes can be found in the <code>serialization.h</code> header file.</p> <pre><code>#include &lt;flashfix/serialization.h&gt;\n</code></pre> <p>These functions don't check the validity of messages, they assume that the message struct is correctly filled with the right values.</p>"},{"location":"api-reference/serialization/#ff_message_fits_in_buffer","title":"ff_message_fits_in_buffer","text":"<pre><code>bool ff_message_fits_in_buffer(const ff_message_t *restrict message, const uint16_t buffer_size, ff_error_t *restrict error);\n</code></pre>"},{"location":"api-reference/serialization/#description","title":"Description","text":"<p>checks if the finalized message derived from the message struct fits in the provided buffer size.</p>"},{"location":"api-reference/serialization/#parameters","title":"Parameters","text":"<ul> <li><code>message</code> - the message struct to be serialized</li> <li><code>buffer_size</code> - the size of the buffer in bytes</li> <li><code>error</code> - an optional pointer to retrieve error information</li> </ul>"},{"location":"api-reference/serialization/#returns","title":"Returns","text":"<ul> <li><code>true</code> if the message fits in the buffer</li> <li><code>false</code> if the message does not fit in the buffer</li> <li><code>false</code> in case of error</li> </ul>"},{"location":"api-reference/serialization/#undefined-behavior","title":"Undefined Behavior","text":"<ul> <li><code>message</code> is NULL</li> <li>message field lengths add up to more than <code>UINT16_MAX</code></li> </ul>"},{"location":"api-reference/serialization/#errors","title":"Errors","text":"<p>this function does not set any errors</p>"},{"location":"api-reference/serialization/#ff_serialize","title":"ff_serialize","text":"<pre><code>uint16_t ff_serialize(char *restrict buffer, const ff_message_t *restrict message, ff_error_t *restrict error);\n</code></pre>"},{"location":"api-reference/serialization/#description_1","title":"Description","text":"<p>serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters</p>"},{"location":"api-reference/serialization/#parameters_1","title":"Parameters","text":"<ul> <li><code>buffer</code> - the buffer where to store the serialized message</li> <li><code>message</code> - the message struct containing the fields to serialize</li> <li><code>error</code> - an optional pointer to retrieve error information</li> </ul>"},{"location":"api-reference/serialization/#returns_1","title":"Returns","text":"<ul> <li>length of the serialized message in bytes</li> <li><code>0</code> in case of error</li> </ul>"},{"location":"api-reference/serialization/#undefined-behavior_1","title":"Undefined Behavior","text":"<ul> <li><code>buffer</code> is <code>NULL</code></li> <li><code>message</code> is <code>NULL</code></li> <li><code>message</code> doesn't fit in the buffer</li> <li>value_len and <code>tag_len</code> are different from the actual length of the value and tag</li> <li><code>n_fields</code> is different from the actual number of fields in the message</li> <li>non printable characters</li> <li><code>message</code> with <code>NULL</code> fields</li> <li><code>message</code> with empty <code>{}</code> fields array</li> <li><code>message</code> with empty <code>\"\"</code> field strings </li> <li><code>message</code> with <code>value_len == 0</code> or <code>tag_len == 0</code></li> <li><code>message</code> with <code>n_fields == 0</code></li> </ul>"},{"location":"api-reference/serialization/#errors_1","title":"Errors","text":"<p>this function does not set any errors</p>"},{"location":"api-reference/serialization/#ff_finalize","title":"ff_finalize","text":"<pre><code>uint16_t ff_finalize(char *restrict buffer, const uint16_t len, ff_error_t *restrict error);\n</code></pre>"},{"location":"api-reference/serialization/#description_2","title":"Description","text":"<p>computes and adds the final beginstring, bodylength and checksum tags to the serialized message in place</p>"},{"location":"api-reference/serialization/#parameters_2","title":"Parameters","text":"<ul> <li><code>buffer</code> - the buffer which contains a serialized message minus beginstring, bodylength and checksum</li> <li><code>len</code> - the length of the serialized message (portion of the buffer that is full) in bytes</li> <li><code>error</code> - an optional pointer to retrieve error information</li> </ul>"},{"location":"api-reference/serialization/#returns_2","title":"Returns","text":"<ul> <li>length of the finalized message in bytes</li> <li><code>0</code> in case of error</li> </ul>"},{"location":"api-reference/serialization/#undefined-behavior_2","title":"Undefined Behavior","text":"<ul> <li><code>buffer</code> is <code>NULL</code></li> <li><code>buffer</code> is nut big enough to contain the final message</li> </ul>"},{"location":"building-and-testing/benchmarks/","title":"Benchmarks","text":"<p>The benchmarks are the result of 1 million iterations per test, with randomly generated tags and values following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure time complexity in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed.</p>"},{"location":"building-and-testing/benchmarks/#comments","title":"Comments:","text":"<ul> <li>The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings.</li> <li>Serialization takes much more time than deserialization, as it involves copying the data to a buffer.</li> <li>Deserialization is generally much faster as it uses zero-copy techniques.</li> </ul>"},{"location":"building-and-testing/benchmarks/#deserialization","title":"Deserialization","text":""},{"location":"building-and-testing/benchmarks/#avx512","title":"AVX512","text":"<p>Not tested yet, feel free to contribute!</p>"},{"location":"building-and-testing/benchmarks/#avx2","title":"AVX2","text":""},{"location":"building-and-testing/benchmarks/#sse","title":"SSE","text":""},{"location":"building-and-testing/benchmarks/#serialization","title":"Serialization","text":""},{"location":"building-and-testing/benchmarks/#avx512_1","title":"AVX512","text":"<p>Not tested yet, feel free to contribute!</p>"},{"location":"building-and-testing/benchmarks/#avx2_1","title":"AVX2","text":""},{"location":"building-and-testing/benchmarks/#sse_1","title":"SSE","text":""},{"location":"building-and-testing/benchmarks/#run-your-own-benchmarks","title":"Run your own benchmarks","text":"<p>To run your own benchmarks you can follow the steps below:</p> <ul> <li>Compile the library as described in the installation guide</li> <li>Compile the benchmark target: <code>cmake --build . --target benchmark</code></li> <li>Run the benchmark executable: <code>./benchmark</code></li> <li>Generate a plot with the results: <code>python3 ./bencmarks/plot.py *.csv</code></li> </ul>"},{"location":"building-and-testing/installation/","title":"Installation Guide","text":"<p>To install FlashFIX you must compile it from source, as that will guarantee the best performance. You can customize the maximum number of FIX fields per message by specifying the FIX_MAX_FIELDS variable at compile time, the default value is 256.</p>"},{"location":"building-and-testing/installation/#requirements","title":"Requirements","text":"<ul> <li>CMake 3.10 or later</li> <li>gcc with c23 support</li> <li>CPU with unaligned memory access support</li> </ul>"},{"location":"building-and-testing/installation/#building","title":"Building","text":"<ul> <li>Clone the repository: <code>git clone https://github.com/Raimo33/FlashFIX.git</code> or download the source code from the release page</li> <li>Generate the build files: <code>cmake .</code> (add <code>-DFIX_MAX_FIELDS=512</code> to change the maximum number of fields)</li> <li>Build the library: <code>cmake --build .</code></li> <li>Install the library: <code>cmake --install .</code> (optional)</li> </ul>"},{"location":"building-and-testing/installation/#testing","title":"Testing","text":"<p>For testing, the library must to be compiled with -DFIX_MAX_FIELDS=64.</p> <ul> <li>Compile the tests: <code>cmake --build . --target test</code></li> <li>Run the test executable: <code>./test</code></li> </ul> <p>in case of failure, please open an issue on GitHub if there isn't one already.</p>"}]}
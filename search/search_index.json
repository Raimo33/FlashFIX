{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlashFIX FlashFIX is a fast and efficient library for working with FIX protocol messages. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API. Getting Started Installation Guide API Reference Examples","title":"Home"},{"location":"#flashfix","text":"FlashFIX is a fast and efficient library for working with FIX protocol messages. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API.","title":"FlashFIX"},{"location":"#getting-started","text":"Installation Guide API Reference Examples","title":"Getting Started"},{"location":"examples/","text":"Examples Serialization #include <flashfix/serialization.h> #define STR_LEN(s) (sizeof(s) - 1) /*...*/ fix_field_t data_fields[5] = { {.tag = \"35\", .value = \"A\", .tag_len = 2, .value_len = 1}, {.tag = \"49\", .value = \"CLIENT123\", .tag_len = 2, .value_len = 9}, {.tag = \"56\", .value = \"SPOT\", .tag_len = 2, .value_len = 4}, {.tag = \"34\", .value = \"1\", .tag_len = 2, .value_len = 1}, {.tag = \"52\", .value = timestamp_str, .tag_len = 2, .value_len = 21}, }; char raw_serialized_data[1024]; const uint16_t data_len = ff_serialize_raw(raw_serialized_data, (const fix_message_t *){fields, 5}); fix_field_t logon_fields[6] = { {.tag = \"35\", .value = \"A\", .tag_len = 2, .value_len = 1}, {.tag = \"49\", .value = \"CLIENT123\", .tag_len = 2, .value_len = 9}, {.tag = \"56\", .value = \"SPOT\", .tag_len = 2, .value_len = 4}, {.tag = \"34\", .value = \"1\", .tag_len = 2, .value_len = 1}, {.tag = \"52\", .value = timestamp_str, .tag_len = 2, .value_len = 21}, {.tag = \"98\", .value = \"0\", .tag_len = 2, .value_len = 1}, }; char serialized_logon[1024]; const uint16_t logon_len = ff_serialize(serialized_logon, (const fix_message_t *){logon_fields, 6}); write(sockfd, raw_serialized_data, data_len); /*...*/ Deserialization #include <flashfix/deserialization.h> /*...*/ char read_buffer[4096]; uint16_t bytes_read = 0; do { bytes_read += read(sockfd, read_buffer, 1024); } while (ff_is_complete(read_buffer, bytes_read) == false); fix_field_t fields[16]; fix_message_t message = {fields, 16}; ff_deserialize(&message, read_buffer, bytes_read); /*...*/","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#serialization","text":"#include <flashfix/serialization.h> #define STR_LEN(s) (sizeof(s) - 1) /*...*/ fix_field_t data_fields[5] = { {.tag = \"35\", .value = \"A\", .tag_len = 2, .value_len = 1}, {.tag = \"49\", .value = \"CLIENT123\", .tag_len = 2, .value_len = 9}, {.tag = \"56\", .value = \"SPOT\", .tag_len = 2, .value_len = 4}, {.tag = \"34\", .value = \"1\", .tag_len = 2, .value_len = 1}, {.tag = \"52\", .value = timestamp_str, .tag_len = 2, .value_len = 21}, }; char raw_serialized_data[1024]; const uint16_t data_len = ff_serialize_raw(raw_serialized_data, (const fix_message_t *){fields, 5}); fix_field_t logon_fields[6] = { {.tag = \"35\", .value = \"A\", .tag_len = 2, .value_len = 1}, {.tag = \"49\", .value = \"CLIENT123\", .tag_len = 2, .value_len = 9}, {.tag = \"56\", .value = \"SPOT\", .tag_len = 2, .value_len = 4}, {.tag = \"34\", .value = \"1\", .tag_len = 2, .value_len = 1}, {.tag = \"52\", .value = timestamp_str, .tag_len = 2, .value_len = 21}, {.tag = \"98\", .value = \"0\", .tag_len = 2, .value_len = 1}, }; char serialized_logon[1024]; const uint16_t logon_len = ff_serialize(serialized_logon, (const fix_message_t *){logon_fields, 6}); write(sockfd, raw_serialized_data, data_len); /*...*/","title":"Serialization"},{"location":"examples/#deserialization","text":"#include <flashfix/deserialization.h> /*...*/ char read_buffer[4096]; uint16_t bytes_read = 0; do { bytes_read += read(sockfd, read_buffer, 1024); } while (ff_is_complete(read_buffer, bytes_read) == false); fix_field_t fields[16]; fix_message_t message = {fields, 16}; ff_deserialize(&message, read_buffer, bytes_read); /*...*/","title":"Deserialization"},{"location":"api-reference/data-structures/","text":"Data Structures Messages Included in the flashfix/structs.h header file. typedef struct { uint16_t tag_len; uint16_t value_len; const char *tag; const char *value; } fix_field_t; typedef struct { fix_field_t fields[FIX_MAX_FIELDS]; uint16_t n_fields; } fix_message_t;","title":"Data Structures"},{"location":"api-reference/data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"api-reference/data-structures/#messages","text":"Included in the flashfix/structs.h header file. typedef struct { uint16_t tag_len; uint16_t value_len; const char *tag; const char *value; } fix_field_t; typedef struct { fix_field_t fields[FIX_MAX_FIELDS]; uint16_t n_fields; } fix_message_t;","title":"Messages"},{"location":"api-reference/deserialization/","text":"Deserialization The following function prototypes can be found in the deserialization.h header file. #include <flashfix/deserialization.h> These functions only verify the structural integrity of messages in terms of format, checksum, and body length. They do not validate the correctness of the messages (e.g. duplicate tags, invalid values, etc.). ff_deserialize uint16_t ff_deserialize(const char *restrict buffer, const uint16_t buffer_size, fix_message_t *restrict message); Description deserializes a fix message by tokenizing the buffer in place : replacing '=' and '\\x01' delimiters with '\\0' and store pointers to the beginning of each field and value in the message struct. Parameters buffer - the buffer which contains the full serialized message buffer_size - the size of the buffer in bytes message - the message struct where to store the deserialized fields, it should have the fields array already allocated and the n_fields field set to the size of the fields array (i.e. the maximum number of fields that can be stored) Returns length of the deserialized message in bytes 0 in case of error (see below) Undefined Behavior buffer is NULL message is NULL message->fields is NULL message->fields is not allocated message->n_fields is different from the actual size of the fields array buffer_size is different from the actual size of the buffer buffer does not contain a full message buffer does not contain a full message buffer contains non printable characters Errors wrong beginstring no body length checksum mismatch body length mismatch too many fields ff_is_complete bool ff_is_complete(const char *buffer, const uint16_t len); Description checks if a buffer contains a full fix message (i.e. it ends with a checksum followed by a '\\x01' delimiter) Parameters buffer - the buffer which contains the full serialized message len - the length of the filled part of the buffer in bytes Returns true if the buffer contains a full message false otherwise Undefined Behavior buffer is NULL len is 0","title":"Deserialization"},{"location":"api-reference/deserialization/#deserialization","text":"The following function prototypes can be found in the deserialization.h header file. #include <flashfix/deserialization.h> These functions only verify the structural integrity of messages in terms of format, checksum, and body length. They do not validate the correctness of the messages (e.g. duplicate tags, invalid values, etc.).","title":"Deserialization"},{"location":"api-reference/deserialization/#ff_deserialize","text":"uint16_t ff_deserialize(const char *restrict buffer, const uint16_t buffer_size, fix_message_t *restrict message);","title":"ff_deserialize"},{"location":"api-reference/deserialization/#description","text":"deserializes a fix message by tokenizing the buffer in place : replacing '=' and '\\x01' delimiters with '\\0' and store pointers to the beginning of each field and value in the message struct.","title":"Description"},{"location":"api-reference/deserialization/#parameters","text":"buffer - the buffer which contains the full serialized message buffer_size - the size of the buffer in bytes message - the message struct where to store the deserialized fields, it should have the fields array already allocated and the n_fields field set to the size of the fields array (i.e. the maximum number of fields that can be stored)","title":"Parameters"},{"location":"api-reference/deserialization/#returns","text":"length of the deserialized message in bytes 0 in case of error (see below)","title":"Returns"},{"location":"api-reference/deserialization/#undefined-behavior","text":"buffer is NULL message is NULL message->fields is NULL message->fields is not allocated message->n_fields is different from the actual size of the fields array buffer_size is different from the actual size of the buffer buffer does not contain a full message buffer does not contain a full message buffer contains non printable characters","title":"Undefined Behavior"},{"location":"api-reference/deserialization/#errors","text":"wrong beginstring no body length checksum mismatch body length mismatch too many fields","title":"Errors"},{"location":"api-reference/deserialization/#ff_is_complete","text":"bool ff_is_complete(const char *buffer, const uint16_t len);","title":"ff_is_complete"},{"location":"api-reference/deserialization/#description_1","text":"checks if a buffer contains a full fix message (i.e. it ends with a checksum followed by a '\\x01' delimiter)","title":"Description"},{"location":"api-reference/deserialization/#parameters_1","text":"buffer - the buffer which contains the full serialized message len - the length of the filled part of the buffer in bytes","title":"Parameters"},{"location":"api-reference/deserialization/#returns_1","text":"true if the buffer contains a full message false otherwise","title":"Returns"},{"location":"api-reference/deserialization/#undefined-behavior_1","text":"buffer is NULL len is 0","title":"Undefined Behavior"},{"location":"api-reference/overview/","text":"Overview Premise Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, they do not validate the correctness of the messages . For more details, refer to the specific sections. Usage The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures . You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashfix.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Overview"},{"location":"api-reference/overview/#overview","text":"","title":"Overview"},{"location":"api-reference/overview/#premise","text":"Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, they do not validate the correctness of the messages . For more details, refer to the specific sections.","title":"Premise"},{"location":"api-reference/overview/#usage","text":"The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures . You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashfix.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Usage"},{"location":"api-reference/serialization/","text":"Serialization The following function prototypes can be found in the serialization.h header file. #include <flashfix/serialization.h> These functions don't check the validity of messages , they assume that the message struct is correctly filled with the right values. ff_serialize uint16_t ff_serialize(char *restrict buffer, const fix_message_t *restrict message); Description serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters and adding the mandatory beginstring, bodylength, and checksum fields. Parameters buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize Returns length of the serialized message in bytes Undefined Behavior buffer is NULL message is NULL message doesn't fit in the buffer value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0 ff_serialize_raw uint16_t ff_serialize_raw(char *restrict buffer, const fix_message_t *restrict message); Description serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters. Parameters buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize. Returns length of the serialized message in bytes Undefined Behavior buffer is NULL message is NULL message doesn't fit in the buffer message->fields is NULL message->fields is not allocated value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0","title":"Serialization"},{"location":"api-reference/serialization/#serialization","text":"The following function prototypes can be found in the serialization.h header file. #include <flashfix/serialization.h> These functions don't check the validity of messages , they assume that the message struct is correctly filled with the right values.","title":"Serialization"},{"location":"api-reference/serialization/#ff_serialize","text":"uint16_t ff_serialize(char *restrict buffer, const fix_message_t *restrict message);","title":"ff_serialize"},{"location":"api-reference/serialization/#description","text":"serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters and adding the mandatory beginstring, bodylength, and checksum fields.","title":"Description"},{"location":"api-reference/serialization/#parameters","text":"buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize","title":"Parameters"},{"location":"api-reference/serialization/#returns","text":"length of the serialized message in bytes","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior","text":"buffer is NULL message is NULL message doesn't fit in the buffer value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0","title":"Undefined Behavior"},{"location":"api-reference/serialization/#ff_serialize_raw","text":"uint16_t ff_serialize_raw(char *restrict buffer, const fix_message_t *restrict message);","title":"ff_serialize_raw"},{"location":"api-reference/serialization/#description_1","text":"serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters.","title":"Description"},{"location":"api-reference/serialization/#parameters_1","text":"buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize.","title":"Parameters"},{"location":"api-reference/serialization/#returns_1","text":"length of the serialized message in bytes","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior_1","text":"buffer is NULL message is NULL message doesn't fit in the buffer message->fields is NULL message->fields is not allocated value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0","title":"Undefined Behavior"},{"location":"building-and-testing/benchmarks/","text":"Benchmarks The benchmarks are the result of 1 million iterations per test, with randomly generated tags and values following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure time complexity in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed. Comments: The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. Serialization takes much more time than deserialization, as it involves copying the data to a buffer. Deserialization is generally much faster as it uses zero-copy techniques. Direct zero-copy serialization with vectorized writev and no memcpy was attempted but resulted in a 3x performance decrease, likely due to the small nature of the FIX fields and tags. Deserialization Serialization Run your own benchmarks To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark Generate a plot with the results: python3 ./benchmarks/plot.py *.csv","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#benchmarks","text":"The benchmarks are the result of 1 million iterations per test, with randomly generated tags and values following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure time complexity in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed.","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#comments","text":"The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. Serialization takes much more time than deserialization, as it involves copying the data to a buffer. Deserialization is generally much faster as it uses zero-copy techniques. Direct zero-copy serialization with vectorized writev and no memcpy was attempted but resulted in a 3x performance decrease, likely due to the small nature of the FIX fields and tags.","title":"Comments:"},{"location":"building-and-testing/benchmarks/#deserialization","text":"","title":"Deserialization"},{"location":"building-and-testing/benchmarks/#serialization","text":"","title":"Serialization"},{"location":"building-and-testing/benchmarks/#run-your-own-benchmarks","text":"To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark Generate a plot with the results: python3 ./benchmarks/plot.py *.csv","title":"Run your own benchmarks"},{"location":"building-and-testing/installation/","text":"Installation Guide To install FlashFIX you must compile it from source, as that will guarantee the best performance. Requirements CMake 3.10 or later gcc with c23 support CPU with unaligned memory access support Building Clone the repository: git clone https://github.com/Raimo33/FlashFIX.git or download the source code from the release page Generate the build files: cmake . Build the library: cmake --build . --parallel Optionally install the library: cmake --install . --parallel Testing Compile the tests: cmake --build . --parallel --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Installation"},{"location":"building-and-testing/installation/#installation-guide","text":"To install FlashFIX you must compile it from source, as that will guarantee the best performance.","title":"Installation Guide"},{"location":"building-and-testing/installation/#requirements","text":"CMake 3.10 or later gcc with c23 support CPU with unaligned memory access support","title":"Requirements"},{"location":"building-and-testing/installation/#building","text":"Clone the repository: git clone https://github.com/Raimo33/FlashFIX.git or download the source code from the release page Generate the build files: cmake . Build the library: cmake --build . --parallel Optionally install the library: cmake --install . --parallel","title":"Building"},{"location":"building-and-testing/installation/#testing","text":"Compile the tests: cmake --build . --parallel --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Testing"}]}
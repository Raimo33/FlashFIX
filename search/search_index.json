{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlashFIX FlashFIX is a fast and efficient library for working with FIX protocol messages. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API. Getting Started Installation Guide API Reference Examples","title":"Home"},{"location":"#flashfix","text":"FlashFIX is a fast and efficient library for working with FIX protocol messages. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API.","title":"FlashFIX"},{"location":"#getting-started","text":"Installation Guide API Reference Examples","title":"Getting Started"},{"location":"examples/","text":"todo","title":"Examples"},{"location":"api-reference/data-structures/","text":"Data Structures Messages Included in the flashfix/structs.h header file. typedef struct { uint16_t tag_len; uint16_t value_len; char *tag; char *value; } ff_field_t; typedef struct { ff_field_t fields[FIX_MAX_FIELDS]; uint16_t n_fields; } ff_message_t; Errors Included in the flashfix/errors.h header file. typedef enum { FF_OK = 0, FF_INVALID_MESSAGE, FF_BODY_LENGTH_MISMATCH, FF_CHECKSUM_MISMATCH, FF_TOO_MANY_FIELDS, FF_MESSAGE_TOO_BIG } ff_error_t;","title":"Data Structures"},{"location":"api-reference/data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"api-reference/data-structures/#messages","text":"Included in the flashfix/structs.h header file. typedef struct { uint16_t tag_len; uint16_t value_len; char *tag; char *value; } ff_field_t; typedef struct { ff_field_t fields[FIX_MAX_FIELDS]; uint16_t n_fields; } ff_message_t;","title":"Messages"},{"location":"api-reference/data-structures/#errors","text":"Included in the flashfix/errors.h header file. typedef enum { FF_OK = 0, FF_INVALID_MESSAGE, FF_BODY_LENGTH_MISMATCH, FF_CHECKSUM_MISMATCH, FF_TOO_MANY_FIELDS, FF_MESSAGE_TOO_BIG } ff_error_t;","title":"Errors"},{"location":"api-reference/deserialization/","text":"Deserialization The following function prototypes can be found in the deserialization.h header file. #include <flashfix/deserialization.h> These functions only verify the structural integrity of messages in terms of format, checksum, and body length. They do not validate the correctness of the messages (e.g. duplicate tags, invalid values, etc.). ff_is_full_message bool ff_is_full_message(const char *restrict buffer, const uint16_t buffer_size, const uint16_t message_len, ff_error_t *restrict error); Description checks if the buffer contains a full FIX message (aka full checksum is present). WARNING : if the buffer is too small (aka the partial message that arrived has filled the whole buffer) there is potential for an infinite loop if you keep repeating the call to ff_is_full_message with the same buffer and buffer_size , the function will yield a FF_MESSAGE_TOO_BIG error in that case, you should only call ff_is_full_message with a NULL error pointer if you have other ways to detect that the buffer is full Parameters buffer - the buffer which contains a full or partial serialized message buffer_size - the size of the buffer in bytes message_len - the length of the serialized message (portion of the buffer that is full) error - an optional pointer to retrieve error information Returns true if the buffer contains a full message false if the buffer contains a partial message false in case of error Undefined Behavior buffer is NULL buffer_size is different from the actual size of the buffer message_len is different from the actual length of the message message_len is bigger than buffer_size Errors FF_MESSAGE_TOO_BIG - the message is too big to fit in the buffer ff_deserialize uint16_t ff_deserialize(char *restrict buffer, const uint16_t buffer_size, ff_message_t *restrict message, ff_error_t *restrict error); Description deserializes a fix message by tokenizing the buffer in place : replacing '=' and '\\x01' delimiters with '\\0' and store pointers to the beginning of each field in the message struct Parameters buffer - the buffer which contains the full serialized message buffer_size - the size of the buffer in bytes message - the message struct where to store the deserialized fields error - an optional pointer to retrieve error information Returns length of the deserialized message in bytes 0 in case of error Undefined Behavior buffer is NULL message is NULL message->n_fields is greater than FIX_MAX_FIELDS buffer_size is different from the actual size of the buffer buffer does not contain a full message buffer contains non printable characters Errors FF_INVALID_MESSAGE - the message does not contain mandatory tags FF_BODY_LENGTH_MISMATCH - the body length tag does not match the actual body length FF_CHECKSUM_MISMATCH - the checksum tag does not match the actual checksum","title":"Deserialization"},{"location":"api-reference/deserialization/#deserialization","text":"The following function prototypes can be found in the deserialization.h header file. #include <flashfix/deserialization.h> These functions only verify the structural integrity of messages in terms of format, checksum, and body length. They do not validate the correctness of the messages (e.g. duplicate tags, invalid values, etc.).","title":"Deserialization"},{"location":"api-reference/deserialization/#ff_is_full_message","text":"bool ff_is_full_message(const char *restrict buffer, const uint16_t buffer_size, const uint16_t message_len, ff_error_t *restrict error);","title":"ff_is_full_message"},{"location":"api-reference/deserialization/#description","text":"checks if the buffer contains a full FIX message (aka full checksum is present). WARNING : if the buffer is too small (aka the partial message that arrived has filled the whole buffer) there is potential for an infinite loop if you keep repeating the call to ff_is_full_message with the same buffer and buffer_size , the function will yield a FF_MESSAGE_TOO_BIG error in that case, you should only call ff_is_full_message with a NULL error pointer if you have other ways to detect that the buffer is full","title":"Description"},{"location":"api-reference/deserialization/#parameters","text":"buffer - the buffer which contains a full or partial serialized message buffer_size - the size of the buffer in bytes message_len - the length of the serialized message (portion of the buffer that is full) error - an optional pointer to retrieve error information","title":"Parameters"},{"location":"api-reference/deserialization/#returns","text":"true if the buffer contains a full message false if the buffer contains a partial message false in case of error","title":"Returns"},{"location":"api-reference/deserialization/#undefined-behavior","text":"buffer is NULL buffer_size is different from the actual size of the buffer message_len is different from the actual length of the message message_len is bigger than buffer_size","title":"Undefined Behavior"},{"location":"api-reference/deserialization/#errors","text":"FF_MESSAGE_TOO_BIG - the message is too big to fit in the buffer","title":"Errors"},{"location":"api-reference/deserialization/#ff_deserialize","text":"uint16_t ff_deserialize(char *restrict buffer, const uint16_t buffer_size, ff_message_t *restrict message, ff_error_t *restrict error);","title":"ff_deserialize"},{"location":"api-reference/deserialization/#description_1","text":"deserializes a fix message by tokenizing the buffer in place : replacing '=' and '\\x01' delimiters with '\\0' and store pointers to the beginning of each field in the message struct","title":"Description"},{"location":"api-reference/deserialization/#parameters_1","text":"buffer - the buffer which contains the full serialized message buffer_size - the size of the buffer in bytes message - the message struct where to store the deserialized fields error - an optional pointer to retrieve error information","title":"Parameters"},{"location":"api-reference/deserialization/#returns_1","text":"length of the deserialized message in bytes 0 in case of error","title":"Returns"},{"location":"api-reference/deserialization/#undefined-behavior_1","text":"buffer is NULL message is NULL message->n_fields is greater than FIX_MAX_FIELDS buffer_size is different from the actual size of the buffer buffer does not contain a full message buffer contains non printable characters","title":"Undefined Behavior"},{"location":"api-reference/deserialization/#errors_1","text":"FF_INVALID_MESSAGE - the message does not contain mandatory tags FF_BODY_LENGTH_MISMATCH - the body length tag does not match the actual body length FF_CHECKSUM_MISMATCH - the checksum tag does not match the actual checksum","title":"Errors"},{"location":"api-reference/overview/","text":"Overview Premise Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, they do not validate the correctness of the messages . For more details, refer to the specific sections. Usage The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures for messages and errors. You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashfix.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Overview"},{"location":"api-reference/overview/#overview","text":"","title":"Overview"},{"location":"api-reference/overview/#premise","text":"Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, they do not validate the correctness of the messages . For more details, refer to the specific sections.","title":"Premise"},{"location":"api-reference/overview/#usage","text":"The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures for messages and errors. You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashfix.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Usage"},{"location":"api-reference/serialization/","text":"Serialization The following function prototypes can be found in the serialization.h header file. #include <flashfix/serialization.h> These functions don't check the validity of messages , they assume that the message struct is correctly filled with the right values. ff_message_fits_in_buffer bool ff_message_fits_in_buffer(const ff_message_t *restrict message, const uint16_t buffer_size, ff_error_t *restrict error); Description checks if the finalized message derived from the message struct fits in the provided buffer size. Parameters message - the message struct to be serialized buffer_size - the size of the buffer in bytes error - an optional pointer to retrieve error information Returns true if the message fits in the buffer false if the message does not fit in the buffer false in case of error Undefined Behavior message is NULL message field lengths add up to more than UINT16_MAX Errors this function does not set any errors ff_serialize uint16_t ff_serialize(char *restrict buffer, const ff_message_t *restrict message, ff_error_t *restrict error); Description serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters Parameters buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize error - an optional pointer to retrieve error information Returns length of the serialized message in bytes 0 in case of error Undefined Behavior buffer is NULL message is NULL message doesn't fit in the buffer value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0 Errors this function does not set any errors ff_finalize uint16_t ff_finalize(char *restrict buffer, const uint16_t len, ff_error_t *restrict error); Description computes and adds the final beginstring, bodylength and checksum tags to the serialized message in place Parameters buffer - the buffer which contains a serialized message minus beginstring, bodylength and checksum len - the length of the serialized message (portion of the buffer that is full) in bytes error - an optional pointer to retrieve error information Returns length of the finalized message in bytes 0 in case of error Undefined Behavior buffer is NULL buffer is nut big enough to contain the final message","title":"Serialization"},{"location":"api-reference/serialization/#serialization","text":"The following function prototypes can be found in the serialization.h header file. #include <flashfix/serialization.h> These functions don't check the validity of messages , they assume that the message struct is correctly filled with the right values.","title":"Serialization"},{"location":"api-reference/serialization/#ff_message_fits_in_buffer","text":"bool ff_message_fits_in_buffer(const ff_message_t *restrict message, const uint16_t buffer_size, ff_error_t *restrict error);","title":"ff_message_fits_in_buffer"},{"location":"api-reference/serialization/#description","text":"checks if the finalized message derived from the message struct fits in the provided buffer size.","title":"Description"},{"location":"api-reference/serialization/#parameters","text":"message - the message struct to be serialized buffer_size - the size of the buffer in bytes error - an optional pointer to retrieve error information","title":"Parameters"},{"location":"api-reference/serialization/#returns","text":"true if the message fits in the buffer false if the message does not fit in the buffer false in case of error","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior","text":"message is NULL message field lengths add up to more than UINT16_MAX","title":"Undefined Behavior"},{"location":"api-reference/serialization/#errors","text":"this function does not set any errors","title":"Errors"},{"location":"api-reference/serialization/#ff_serialize","text":"uint16_t ff_serialize(char *restrict buffer, const ff_message_t *restrict message, ff_error_t *restrict error);","title":"ff_serialize"},{"location":"api-reference/serialization/#description_1","text":"serializes a fix message into a buffer by concatenating the fields with '=' and '\\x01' delimiters","title":"Description"},{"location":"api-reference/serialization/#parameters_1","text":"buffer - the buffer where to store the serialized message message - the message struct containing the fields to serialize error - an optional pointer to retrieve error information","title":"Parameters"},{"location":"api-reference/serialization/#returns_1","text":"length of the serialized message in bytes 0 in case of error","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior_1","text":"buffer is NULL message is NULL message doesn't fit in the buffer value_len and tag_len are different from the actual length of the value and tag n_fields is different from the actual number of fields in the message non printable characters message with NULL fields message with empty {} fields array message with empty \"\" field strings message with value_len == 0 or tag_len == 0 message with n_fields == 0","title":"Undefined Behavior"},{"location":"api-reference/serialization/#errors_1","text":"this function does not set any errors","title":"Errors"},{"location":"api-reference/serialization/#ff_finalize","text":"uint16_t ff_finalize(char *restrict buffer, const uint16_t len, ff_error_t *restrict error);","title":"ff_finalize"},{"location":"api-reference/serialization/#description_2","text":"computes and adds the final beginstring, bodylength and checksum tags to the serialized message in place","title":"Description"},{"location":"api-reference/serialization/#parameters_2","text":"buffer - the buffer which contains a serialized message minus beginstring, bodylength and checksum len - the length of the serialized message (portion of the buffer that is full) in bytes error - an optional pointer to retrieve error information","title":"Parameters"},{"location":"api-reference/serialization/#returns_2","text":"length of the finalized message in bytes 0 in case of error","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior_2","text":"buffer is NULL buffer is nut big enough to contain the final message","title":"Undefined Behavior"},{"location":"building-and-testing/benchmarks/","text":"Benchmarks The benchmarks are the result of 1 million iterations per test, with randomly generated tags and values following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure time complexity in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed. Comments: The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. Serialization takes much more time than deserialization, as it involves copying the data to a buffer. Deserialization is generally much faster as it uses zero-copy techniques. Deserialization AVX512 Not tested yet, feel free to contribute! AVX2 SSE Serialization AVX512 Not tested yet, feel free to contribute! AVX2 SSE Run your own benchmarks To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark Generate a plot with the results: python3 ./bencmarks/plot.py *.csv","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#benchmarks","text":"The benchmarks are the result of 1 million iterations per test, with randomly generated tags and values following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure time complexity in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed.","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#comments","text":"The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. Serialization takes much more time than deserialization, as it involves copying the data to a buffer. Deserialization is generally much faster as it uses zero-copy techniques.","title":"Comments:"},{"location":"building-and-testing/benchmarks/#deserialization","text":"","title":"Deserialization"},{"location":"building-and-testing/benchmarks/#avx512","text":"Not tested yet, feel free to contribute!","title":"AVX512"},{"location":"building-and-testing/benchmarks/#avx2","text":"","title":"AVX2"},{"location":"building-and-testing/benchmarks/#sse","text":"","title":"SSE"},{"location":"building-and-testing/benchmarks/#serialization","text":"","title":"Serialization"},{"location":"building-and-testing/benchmarks/#avx512_1","text":"Not tested yet, feel free to contribute!","title":"AVX512"},{"location":"building-and-testing/benchmarks/#avx2_1","text":"","title":"AVX2"},{"location":"building-and-testing/benchmarks/#sse_1","text":"","title":"SSE"},{"location":"building-and-testing/benchmarks/#run-your-own-benchmarks","text":"To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark Generate a plot with the results: python3 ./bencmarks/plot.py *.csv","title":"Run your own benchmarks"},{"location":"building-and-testing/installation/","text":"Installation Guide To install FlashFIX you must compile it from source, as that will guarantee the best performance. You can customize the maximum number of FIX fields per message by specifying the FIX_MAX_FIELDS variable at compile time, the default value is 256. Requirements CMake 3.10 or later gcc with c23 support CPU with unaligned memory access support Building Clone the repository: git clone https://github.com/Raimo33/FlashFIX.git or download the source code from the release page Generate the build files: cmake . (add -DFIX_MAX_FIELDS=512 to change the maximum number of fields) Build the library: cmake --build . Install the library: cmake --install . (optional) Testing For testing, the library must to be compiled with -DFIX_MAX_FIELDS=64. Compile the tests: cmake --build . --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Installation"},{"location":"building-and-testing/installation/#installation-guide","text":"To install FlashFIX you must compile it from source, as that will guarantee the best performance. You can customize the maximum number of FIX fields per message by specifying the FIX_MAX_FIELDS variable at compile time, the default value is 256.","title":"Installation Guide"},{"location":"building-and-testing/installation/#requirements","text":"CMake 3.10 or later gcc with c23 support CPU with unaligned memory access support","title":"Requirements"},{"location":"building-and-testing/installation/#building","text":"Clone the repository: git clone https://github.com/Raimo33/FlashFIX.git or download the source code from the release page Generate the build files: cmake . (add -DFIX_MAX_FIELDS=512 to change the maximum number of fields) Build the library: cmake --build . Install the library: cmake --install . (optional)","title":"Building"},{"location":"building-and-testing/installation/#testing","text":"For testing, the library must to be compiled with -DFIX_MAX_FIELDS=64. Compile the tests: cmake --build . --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Testing"}]}